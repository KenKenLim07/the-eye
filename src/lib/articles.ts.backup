import { createClient } from "@supabase/supabase-js";

const supabaseServer = createClient(
  process.env.NEXT_PUBLIC_SUPABASE_URL!,
  process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!
);

export interface Article {
  id: number;
  source: string;
  category: string | null;
  raw_category: string | null;
  title: string;
  url: string;
  content: string;
  published_at: string;
  created_at: string;
}

export async function fetchAllArticles(limit: number = 10): Promise<Record<string, Article[]>> {
  const sources = [
    "GMA",
    "Inquirer",
    "Philstar",  // Fixed: was "PhilStar"
    "Sunstar",
    "Manila Bulletin",
    "Manila Times",
    "Rappler"
  ];

  // Create parallel queries for all sources
  const queries = sources.map(source => 
    supabaseServer
      .from("articles")
      .select("*")
      .eq("source", source)
      .order("published_at", { ascending: false })
      .limit(limit)
  );

  // Execute all queries in parallel
  const results = await Promise.all(queries);
  
  // Process results
  const articlesBySource: Record<string, Article[]> = {};

  results.forEach((result, index) => {
    const source = sources[index];
    if (result.error) {
      console.error(`Error fetching ${source}:`, result.error);
      articlesBySource[source] = [];
    } else {
      articlesBySource[source] = (result.data as Article[]) || [];
    }
  });

  return articlesBySource;
}

export interface AnalysisRow {
  id: number;
  article_id: number;
  model_version: string;
  model_type: string;
  sentiment_score: number | null;
  sentiment_label: string | null;
  confidence_score: number | null;
  processing_time_ms: number | null;
  model_metadata: any;
  created_at: string;
}

export interface BulkAnalysisResponse {
  analysis: AnalysisRow[];
}

export interface FetchAnalysisResult {
  map: Record<number, AnalysisRow | null>;
  unavailable: boolean; // true when API request failed/unreachable
}

export async function fetchLatestAnalysisByIds(articleIds: number[]): Promise<FetchAnalysisResult> {
  if (articleIds.length === 0) return { map: {}, unavailable: false };

  try {
    const baseUrl = process.env.NEXT_PUBLIC_BACKEND_URL || 'http://localhost:8000';
    if (!baseUrl.startsWith('http')) {
      console.error('Invalid NEXT_PUBLIC_BACKEND_URL. Expected absolute URL, got:', baseUrl);
      return { map: {}, unavailable: true };
    }

    const params = new URLSearchParams({
      ids: articleIds.join(','),
      model_type: 'sentiment',
      model_version: 'vader_v1',
    });

    const response = await fetch(
      `${baseUrl}/ml/analysis?${params.toString()}`,
      { cache: 'no-store', signal: AbortSignal.timeout(15000) }
    );
    
    if (!response.ok) {
      throw new Error(`HTTP ${response.status}`);
    }
    
    const data = await response.json();
    
    // If the response contains an error
    if (data.error) {
      console.error('API returned error:', data.error);
      return { map: {}, unavailable: true };
    }
    
    if (!data.analysis || !Array.isArray(data.analysis)) {
      console.error('Invalid response format:', data);
      return { map: {}, unavailable: true };
    }
    
    const latestByArticle: Record<number, AnalysisRow> = {};
    for (const analysis of data.analysis as AnalysisRow[]) {
      const articleId = analysis.article_id;
      if (!latestByArticle[articleId] || new Date(analysis.created_at) > new Date(latestByArticle[articleId].created_at)) {
        latestByArticle[articleId] = analysis;
      }
    }
    
    const analysisMap: Record<number, AnalysisRow | null> = {};
    for (const articleId of articleIds) {
      analysisMap[articleId] = latestByArticle[articleId] || null;
    }
    
    // unavailable=false even if map is empty; it just means no data yet
    return { map: analysisMap, unavailable: false };
  } catch (error) {
    console.error('Failed to fetch analysis:', error);
    return { map: {}, unavailable: true };
  }
}
